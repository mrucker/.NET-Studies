addpath('./kernels');

lambda = 1;

os = 100;
ps = 1;

xs = rand(ps,os) * 10;
ys = (xs).^2;

%dk = @(xi)       (xs*xs' + eye(ps)*lambda)^-1 * xs*ys'    ; %traditional solution
%dk = @(xi) xs  * (xs'*xs + eye(os)*lambda)^-1 * ys'       ; %transpose'd solution


dk_1 = @(xi) ys  * (K(xs,xs,1) + eye(os)*lambda)^-1 * K(xs,xi,1); %
dk_2 = @(xi) ys  * (K(xs,xs,2) + eye(os)*lambda)^-1 * K(xs,xi,2); %kernel ready solution

fprintf('%.2f\n', mean((ys - dk(xs)).^2))

draw(xs,ys,dk,100);

%Drawers
function draw (xs, ys, dk, steps)
    max_x = max(xs);
    min_x = min(xs);

    rx = (min_x:(max_x-min_x)/steps:max_x);
    ry = dk(rx);

    clf
    hold on
    %axis([min_x max_x min_y max_y]);

    scatter(xs,ys, [], 'r', 'o');
    scatter(rx,ry, [], 'g', '.');

    hold off
end
%Drawers

%Kernels
function k = K(x1, x2, k_i)
    p = 10.0;
    c = 2.0;
    s = 10;
    n = size(x1,1);
        
    switch k_i
        case 1
            b = k_dot();
        case 2
            b = k_polynomial(k_dot(),p,c);
        case 3
            b = k_hamming(0);
        case 4
            b = k_equal(k_norm());
        case 5
            b = k_gaussian(k_norm(),s);
        case 6
            b = k_exponential(k_norm(),s);
        case 7
            b = k_anova(n);
        case 8
            b = k_exponential_compact(k_norm(),s);
    end
       
    k = b(x1,x2);
end